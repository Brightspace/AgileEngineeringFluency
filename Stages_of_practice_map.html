<!DOCTYPE html>
<html>
<head>
	<title>Adaptive Engineering Proficiencies</title>
	<script type="text/javascript">
		function each_item(obj, op) {
			for (var key in obj) {
				op(obj[key], key);
			}
		}
		function each_elt(arr, op) {
			for (var i = 0, m = arr.length; i < m; ++i) {
				op(arr[i], i);
			}
		}
		function map_item(obj, op, create_fn) {
			create_fn = create_fn || empty_instance_of_same_class;
			var result = create_fn(obj);
			for (var key in obj) {
				result[key] = op(obj[key], key);
			}
			return result;
		}
		function map_elt(arr, op) {
			var result = [];
			for (var i = 0, m = arr.length; i < m; ++i) {
				result.push(op(arr[i], i));
			}
			return result;
		}

		function Clone() { }
		function clone(obj) {
			Clone.prototype = obj;
			return new Clone();
		}
		function empty_instance_of_same_class(obj) {
			return clone(obj.prototype);
		}
		function decorate(obj, decorator) {
			var result = clone(obj);
			for (var key in decorator) {
				result[key] = decorator[key];
			}
			return result;
		}
		function base_class(constructor, methods) {
			for (var key in methods) {
				constructor.prototype[key] = methods[key];
			}
		}
		function extend(superclass, subclass, methods) {
			subclass.prototype = clone(superclass.prototype);
			subclass.prototype.constructor = subclass;
			for (var key in methods) {
				subclass.prototype[key] = methods[key];
			}
		}

		function create_items(inputs, constructor, options) {
			return _wrap_items(inputs, function (input) { return new constructor(input, options); });
		}

		function _wrap_items(inputs, wrap_item) {
			return map_item(inputs, function (input, key) {
				var elt = wrap_item(input);
				elt._id = key;
				return elt;
			});
		}

		function hash_to_array(hash) {
			var result = [];
			each_item(hash, function (item) {
				result.push(item);
			});
			return result;
		}

		function if_err(fn, with_err, no_err) {
			var result;
			try {
				result = fn.call(this);
			} catch (err) {
				with_err.call(this, err);
				return;
			}
			no_err.call(this, result);
		}

		function ViewModel() {
			var vm = this;
			this._id = "whole_app";
			this.close_options = function () {
				vm.expanded(false);
			};
			this.open_options = function () {
				vm.expanded(true);
			};
			this.app = new StagesVm(layout);
			this.expanded = ko.observable(false);
			this.json_blob = ko.computed({
				read: function () {
					var info = this.app.to_JS();
					return JSON.stringify(info, undefined, '\t');
				},
				write: function (value) {
					if_err.call(this, function () { return JSON.parse(value); },
						function (err) { this.app.set_data_error("Unable to parse the JSON."); },
						function (data) {
							this.app.update_data(data);
						});
				},
				owner: vm
			});
		}

		var StagesVm = function () {
			function StagesVm(layout) {
				this.valid = ko.observable(true);
				this.error_message = ko.observable("");
				this.skills = ko.observable([]);
				this.levels = ko.observable([]);
				this.kinds = ko.observable([]);
				this.components = ko.observable([]);
				this._id = "stages";
				this.focal_skill = ko.observable(null);
				var self = this;
				this.show_skill_details = function (skill) {
					self.focal_skill(skill);
				};
				this.hide_skill_details = function () {
					self.focal_skill(null);
				};
			}
			base_class(StagesVm, {
				to_JS: function () {
					return {
						levels: unwrap_to_hash(this.levels),
						components: unwrap_to_hash(this.components),
						dependency_kinds: unwrap_to_hash(this.kinds),
						skills: unwrap_to_hash(this.skills),
					};
				},
				set_data_error: function (reason) {
					this.valid(false);
					this.error_message(reason);
				},
				update_data: function (data) {
					this.valid(true);
					this.error_message("");
					var self = this;
					function mark_invalid(msg_fn) {
						self.valid(false);
						var args = Array.prototype.slice.call(arguments, 1);
						self.error_message(msg_fn.apply(null, args));
						return null;
					}
					var lookup = {
						levels: create_items(data.levels, LevelVm),
						components: create_items(data.components, ComponentVm),
						kinds: create_items(data.dependency_kinds, KindVm),
						skills: create_items(data.skills, SkillVm, layout),
					};
					each_item(lookup.skills, function (skill) {
						skill.resolve_obj_references(lookup, mark_invalid);
					});
					if (!this.valid()) { return; }
					this.skills(hash_to_array(lookup.skills));
					this.levels(hash_to_array(lookup.levels));
					this.kinds(hash_to_array(lookup.kinds));
					this.components(hash_to_array(lookup.components));
				},
			});

			function unwrap_to_hash(arr) {
				var result = {};
				each_elt(ko.utils.unwrapObservable(arr), function (vm) {
					result[vm._id] = vm.to_JS(ko.utils.unwrapObservable);
				});
				return result;
			}

			return StagesVm;
		}();

		var LevelVm = function () {
			function LevelVm(data) {
				this.name = ko.observable(data.name);
				this.min = data.min;
				this.max = data.max;
				this.color = data.color;
			}
			base_class(LevelVm, {
				to_JS: function (unwrap) {
					return {
						name: unwrap(this.name),
						min: unwrap(this.min),
						max: unwrap(this.max),
						color: unwrap(this.color),
					};
				}
			});
			return LevelVm;
		}();

		var ComponentVm = function () {
			function ComponentVm(data) {
				this.name = ko.observable(data.name);
				this.color = data.color;
			}
			base_class(ComponentVm, {
				to_JS: function (unwrap) {
					return {
						name: unwrap(this.name),
						color: unwrap(this.color),
					};
				}
			});
			return ComponentVm;
		}();

		var KindVm = function () {
			function KindVm(data) {
				this.name = ko.observable(data.name);
				this.dash_style = data.dash_style;
			}
			base_class(KindVm, {
				to_JS: function (unwrap) {
					return {
						name: unwrap(this.name),
						dash_style: unwrap(this.dash_style),
					};
				}
			});
			return KindVm;
		}();

		var SkillVm = function () {
			function SkillVm(data, layout) {
				this.name = ko.observable(data.name);
				this.x = data.x;
				this.y = data.y;
				this.level = data.level;
				this.component = data.component;
				this.requires = data.requires;
				this.label_position = layout.place_label(this);
			}
			base_class(SkillVm, {
				to_JS: function (unwrap) {
					return {
						name: unwrap(this.name),
						x: unwrap(this.x),
						y: unwrap(this.y),
						level: unwrap(this.level)._id,
						component: unwrap(this.component)._id,
						requires: map_elt(unwrap(this.requires), function (link) {
							return {
								skill: link.skill._id,
								kind: link.kind._id,
							}
						}),
					};
				},
				resolve_obj_references: function (lookup, mark_invalid) {
					var skill_id = this._id;
					this.component = lookup.components[this.component] || mark_invalid(error_failed_to_find_key, "component", this.component, skill_id);
					this.level = lookup.levels[this.level] || mark_invalid(error_failed_to_find_key, "level", this.level, skill_id);
					this.requires = map_elt(this.requires, function (link) {
						return {
							skill: lookup.skills[link.skill] || mark_invalid(error_failed_to_find_key, "skill", link.skill, skill_id),
							kind: lookup.kinds[link.kind] || mark_invalid(error_failed_to_find_key, "dependency kind", link.kind, skill_id),
						};
					});
				},
			});
			function error_failed_to_find_key(type, key, skill_key) {
				return "I could not find the " + type + " " + key + ", as referenced in the skill " + skill_key + ".";
			}
			return SkillVm;
		}();

		function Painter(canvas) {
			var self = this;
			var canvas = canvas;
			var ctx = canvas.getContext("2d");

			this.prepare = function () {
				ctx.translate(0.5, 0.5);
			}

			this.erase = function () {
				ctx.clearRect(-0.5, -0.5, canvas.width, canvas.height);
			}

			this.draw_filled_circle = function (point, radius, border_thickness, color) {
				ctx.beginPath();
				ctx.strokeStyle = "black";
				ctx.fillStyle = color;
				ctx.lineWidth = border_thickness;
				ctx.arc(point.x, point.y, radius, 0, Math.PI * 2, true);
				ctx.fill();
				ctx.stroke();
			}

			this.draw_bezier_curve = function (bezierPoints, color, thickness, dash_style) {
				ctx.beginPath();
				ctx.strokeStyle = color;
				ctx.lineWidth = thickness;
				ctx.setLineDash(dash_style);
				ctx.moveTo(bezierPoints.start.x, bezierPoints.start.y);
				ctx.bezierCurveTo(bezierPoints.cp1.x, bezierPoints.cp1.y,
					bezierPoints.cp2.x, bezierPoints.cp2.y,
					bezierPoints.end.x, bezierPoints.end.y);
				ctx.stroke();
				ctx.setLineDash([]);
			}

			this.draw_open_circle = function (center, radius) {
				ctx.beginPath();
				ctx.strokeStyle = "black";
				ctx.lineWidth = "1";
				ctx.arc(center.x, center.y, radius, 0, Math.PI, true);
				ctx.arc(center.x, center.y, radius, Math.PI, Math.PI * 2, true);
				ctx.stroke();
			}

			this.draw_text = function (text, font, where) {
				ctx.font = font;
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				ctx.fillStyle = "black";

				ctx.beginPath();
				ctx.fillText(text, where.x, where.y);
				ctx.fill();
			}

			this.draw_vertical_bar = function (x1, x2, color) {
				ctx.fillStyle = color;
				ctx.strokeStyle = color;
				ctx.fillRect(x1, -1, x2 - x1 + 1, canvas.height + 1);
			}

			this.draw_dashed_line = function (start, end) {
				ctx.beginPath();
				ctx.strokeStyle = "gray";
				ctx.setLineDash([3]);
				ctx.lineWidth = "0.5";
				ctx.moveTo(start.x, start.y);
				ctx.lineTo(end.x, end.y);
				ctx.stroke();
				ctx.setLineDash([]);
			}
		}

		function LayoutSpecialist() {
			var PIXELS_BETWEEN_LOGICAL_GRID_POSITIONS = { x: 120, y: 80 };
			var OFFSET_TO_GRID_ORIGIN = 40;
			var self = this;

			this.translatePoint = function (point) {
				return {
					x: self.translate_position_x(point.x),
					y: self.translate_position_y(point.y)
				};
			};

			this.translate_position_x = function (pos) {
				return (pos * PIXELS_BETWEEN_LOGICAL_GRID_POSITIONS.x) + OFFSET_TO_GRID_ORIGIN;
			};

			this.translate_position_y = function (pos) {
				return (pos * PIXELS_BETWEEN_LOGICAL_GRID_POSITIONS.y) + OFFSET_TO_GRID_ORIGIN;
			};

			this.curve_connecting = function (start, end) {
				return new Bezier(layout.translatePoint(start), layout.translatePoint(end));
			};

			this.place_label = function (skill) {
				return {
					left: this.translate_position_x(skill.x) + 9 + "px",
					top: this.translate_position_y(skill.y) - 26 + "px",
				};
			};
		}
		var layout = new LayoutSpecialist();

		var Bezier = function () {
			var X_BIAS = 0.6; // controls how much the curves should be "pulled" on the x-axis
			var Y_BIAS = 0.0; // controls how much the curves should be "pulled" on the y-axis
			function Bezier(start, end) {
				var dx = end.x - start.x;
				var dy = end.y - start.y;

				this.start = start;
				this.end = end;
				this.cp1 = { x: start.x + dx * X_BIAS, y: start.y + dy * Y_BIAS };
				this.cp2 = { x: end.x - dx * X_BIAS, y: end.y - dy * Y_BIAS };
			}
			base_class(Bezier, {
				draw: function (painter, color, thickness, dash_style) {
					if (this.start.x >= this.end.x) {
						painter.draw_bezier_curve(this, "red", thickness + 4, []);
					}
					painter.draw_bezier_curve(this, color, thickness, dash_style);
				},
				draw_debug_info: function (painter) {
					draw_indicator_lines(this, painter);
					draw_control_point(this.cp1, "cp1", painter);
					draw_control_point(this.cp2, "cp2", painter);
					draw_point_coords_label(this.start, "start", painter);
					draw_point_coords_label(this.end, "end", painter);
				},
			});

			function draw_indicator_lines(self, painter) {
				painter.draw_dashed_line(self.start, self.cp1);
				painter.draw_dashed_line(self.end, self.cp2);
			}

			function draw_control_point(where, label, painter) {
				painter.draw_open_circle(where, 4);
				draw_point_coords_label(where, label, painter);
			}

			function draw_point_coords_label(point, text, painter) {
				painter.draw_text(text + ": (" + point.x + "," + point.y + ")", "10px segui", { x: point.x + 10, y: point.y });
			}
			return Bezier;
		}();

		function extend_ko() {
			var MARKER_RADIUS = 6;
			var MARKER_BORDER_THICKNESS = 2;
			var CONNECTOR_THICKNESS = 3;

			var mainCanvas = document.getElementById("skillsCanvas");
			var debugCanvas = document.getElementById("debugCanvas");

			var prepare_canvas = function () {
				debugCanvas.width = mainCanvas.width;
				debugCanvas.height = mainCanvas.height;
				new Painter(mainCanvas).prepare();
				new Painter(debugCanvas).prepare();
			}

			var populate_canvas = function (parsedData) {
				var draw_context = {
					skills: parsedData.skills(),
					levels: parsedData.levels(),
					mainPainter: new Painter(mainCanvas),
					debugPainter: new Painter(debugCanvas),
				};

				draw_context.mainPainter.erase();
				draw_context.debugPainter.erase();

				for (var level_id in draw_context.levels) {
					draw_level_background(draw_context, draw_context.levels[level_id]);
				}

				for (var skill_id in draw_context.skills) {
					draw_prereq_links(draw_context.skills[skill_id], draw_context);
				}

				for (var skill_id in draw_context.skills) {
					draw_skill_marker(draw_context.mainPainter, draw_context.skills[skill_id]);
				}
			}

			function draw_level_background(draw_context, level) {
				draw_context.mainPainter.draw_vertical_bar(
					layout.translate_position_x(level.min - 0.5),
					layout.translate_position_x(level.max + 0.5),
					level.color);
			}

			function draw_skill_marker(painter, skill) {
				var where = layout.translatePoint(skill);
				painter.draw_filled_circle(where, MARKER_RADIUS, MARKER_BORDER_THICKNESS, skill.component.color);
			}

			function draw_prereq_links(skill, draw_context) {
				for (var i = 0, m = skill.requires.length; i < m; i++) {
					var requirement = skill.requires[i];
					var prereq = requirement.skill;
					var link = layout.curve_connecting(prereq, skill);
					link.draw(draw_context.mainPainter, skill.component.color, CONNECTOR_THICKNESS, requirement.kind.dash_style);
					link.draw_debug_info(draw_context.debugPainter);
				}
			}

			ko.bindingHandlers.stages = {
				init: function (element, value_accessor) {
					prepare_canvas();
				},
				update: function (element, value_accessor) {
					populate_canvas(ko.unwrap(value_accessor()));
				},
			};
		}
	</script>
	<script type="text/javascript" src="stages_data.js">
	</script>
	<script type="text/javascript" src="knockout-3.0.0.js">
	</script>
	<script type="text/javascript" src="knockout.mapping-2.4.1.js">
	</script>
	<script type="text/javascript">
		function start() {
			extend_ko();
			vm = new ViewModel();
			vm.json_blob(JSON.stringify(stages_data(), undefined, '\t'));
			ko.applyBindings(vm);
		}
	</script>
	<style>
		html, body, div {
			margin: 0;
			padding: 0;
			border: 0 solid black;
		}

		h1, h2, h3, h4, h5, h6 {
			font-size: 100%;
			margin: 0;
			padding: 0;
			font-weight: normal;
			font-style: normal;
		}

		html, body {
			height: 100%;
			width: 100%;
			font-size: 10px;
			font-family: "Segoe UI","Times New Roman",serif;
			line-height: 1.0;
		}

		.display_port {
			position: relative;
		}

		.canvas {
			background-color: transparent;
			position: absolute;
		}

		.drawing {
			z-index: 0;
		}

		.debug {
			z-index: 1000;
			display: none;
		}

		#options_pane {
			position: fixed;
			z-index: 2;
			left: 0;
			bottom: 0;
			width: 100%;
			background-color: white;
			border-top: 1px solid black;
			padding: 0.2em;
			font-size: 1.4em;
			line-height: 1.3;
		}

		#main_pane {
			position: relative;
			z-index: 0;
			width: 2500px;
			height: 1200px;
		}

		.extra_scroll_space {
			padding-bottom: 23.3em;
		}

		.hidden {
			display: none;
		}

		.options_corner {
			position: fixed;
			z-index: 1;
			bottom: 0;
			left: 0;
			height: 25px;
			width: 25px;
			cursor: pointer;
		}

		.invalid {
			border: 2px solid red;
		}

		.error_display {
			color: red;
			margin: 0 2em;
		}

		.skill_focus_dialog {
			background-color: rgba(0,0,0,0.5);
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 5;
			cursor: pointer;
		}

			.skill_focus_dialog .contents {
				background-color: #FFF;
				position: absolute;
				top: 80px;
				left: 100px;
				right: 100px;
				bottom: 80px;
				cursor: default;
				overflow-y: scroll;
			}

		.skill_text.collapsed {
			width: 86px;
			overflow: hidden;
			overflow-wrap: break-word;
		}

			.skill_text.collapsed:hover {
				border: 2px solid #000080;
				padding: 6px;
				cursor: pointer;
			}

		.skill_text {
			position: absolute;
			z-index: 2000;
			font-size: 1.4em;
			line-height: 1.3;
			padding: 8px;
			background-color: rgba(255,255,255,0.3);
			border-radius: 15px;
		}
	</style>
</head>
<body onload="start();">
	<div id="app_with_options" class="display_port">
		<div id="main_pane" data-bind="css: { extra_scroll_space: expanded }, stages: app, with: app">
			<canvas id="skillsCanvas" width="6080" height="1200" class="drawing canvas"></canvas>
			<canvas id="debugCanvas" class="debug canvas"></canvas>
			<!-- ko foreach: skills -->
			<div class="skill_text collapsed" data-bind="style: { top: label_position.top, left: label_position.left }, click: $parent.show_skill_details">
				<span class="name" data-bind="text: name"></span>
			</div>
			<!-- /ko -->
		</div>
		<img class="options_corner" src="page-fold.png" data-bind="click: open_options" />
		<div id="options_pane" data-bind="css: { hidden: !expanded() }">
			<p style="padding-left:2em;">
				Enter JSON data here to update the diagram
				<button data-bind="click: close_options" style="margin-left:2em;">Close</button>
				<span class="error_display" data-bind="text: app.error_message()"></span>
			</p>
			<textarea id="jsonInput" cols="120" rows="20" style="clear:both;" data-bind="value: json_blob, valueUpdate: 'afterkeydown', css: { invalid: !app.valid() }"></textarea>
		</div>
	</div>
	<div class="skill_focus_dialog" data-bind="css: { hidden: !app.focal_skill() }, click: app.hide_skill_details">
		<div class="contents" data-bind="click: function(){}, clickBubble: false, with: app.focal_skill()">
			<h1 data-bind="text: name"></h1>
		</div>
	</div>
</body>
</html>
